<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>OuyangSheng&#39;s Blog</title>
  
  <subtitle>Thinking,Tech....</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-04-24T09:05:09.425Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>OuyangSheng</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>从头开始移植Ubuntu系统到ARM平台（基于全志H3）</title>
    <link href="http://yoursite.com/2018/04/20/Build-Ubuntu-for-ARM-Platform-From-Scratch/"/>
    <id>http://yoursite.com/2018/04/20/Build-Ubuntu-for-ARM-Platform-From-Scratch/</id>
    <published>2018-04-20T08:35:17.000Z</published>
    <updated>2018-04-24T09:05:09.425Z</updated>
    
    <content type="html"><![CDATA[<img src="/2018/04/20/Build-Ubuntu-for-ARM-Platform-From-Scratch/linux.jpg"><h3 id="起点"><a href="#起点" class="headerlink" title="起点"></a>起点</h3><p>在ARM SOC上移植Ubuntu系统并不是一件容易的事情，要对镜像文件的组成，系统的启动顺序非常熟悉。在网上searching一番，发现一个很神奇的网站-&gt;<a href="https://docs.armbian.com/Developer-Guide_Build-Preparation/" target="_blank" rel="noopener">Armbian</a>,这个网站开发者在大量的开发板上做了移植工作，包括allwinner H3/H5、Rockchip RK3328、amlogic S905x等，并且有详细的文档，以及开源的编译系统。</p><p>其实，参考Armbian的文档，即可搭建好完整编译环境，并针对你的板子（前提是里面已经支持的SoC）修改uboot、kernel、编译脚本即可定制，都是开源的。我尝试在H3平台上搭建，并成功制作了镜像，进到了系统。</p><h3 id="编译系统"><a href="#编译系统" class="headerlink" title="编译系统"></a>编译系统</h3><p>如果需要定制一些功能，如添加、删除一些脚本，应用程序，就必须完整看懂整个编译逻辑。Armbian上介绍是：</p><img src="/2018/04/20/Build-Ubuntu-for-ARM-Platform-From-Scratch/process.png"><p>从<a href="http://docs.khadas.com/social/MapoutBuildUbuntuFromScratch/" target="_blank" rel="noopener">khadas开发板网站</a> 上有更形象的图（但未必准确，尤其是对Initramfs与inittrd的理解）：</p><img src="/2018/04/20/Build-Ubuntu-for-ARM-Platform-From-Scratch/map.png"><p>对照编译脚本来看：</p><p>从根目录<code>compile.sh</code>开始，进入<code>main.sh</code>，主要工作在后者里完成，关键步骤：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">1# Check <span class="keyword">and</span> install dependencies, directory structure <span class="keyword">and</span> settings</span><br><span class="line">prepare_host</span><br><span class="line"><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span>.</span><br><span class="line">2# 下载uboot及kernel</span><br><span class="line">fetch_from_repo <span class="string">"<span class="variable">$BOOTSOURCE</span>"</span> <span class="string">"<span class="variable">$BOOTDIR</span>"</span> <span class="string">"<span class="variable">$BOOTBRANCH</span>"</span> <span class="string">"yes"</span></span><br><span class="line">fetch_from_repo <span class="string">"<span class="variable">$KERNELSOURCE</span>"</span> <span class="string">"<span class="variable">$KERNELDIR</span>"</span> <span class="string">"<span class="variable">$KERNELBRANCH</span>"</span> <span class="string">"yes"</span></span><br><span class="line"><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span>.</span><br><span class="line">3# Compile u-boot <span class="keyword">if</span> packed .deb does <span class="keyword">not</span> exist</span><br><span class="line">compile_uboot</span><br><span class="line"><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span>.</span><br><span class="line">4# Compile kernel <span class="keyword">if</span> packed .deb does <span class="keyword">not</span> exist</span><br><span class="line">compile_kernel</span><br><span class="line"><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span>.</span><br><span class="line">5# create board support package /create desktop package / build additional packages</span><br><span class="line">create_board_package</span><br><span class="line">create_desktop_package</span><br><span class="line">chroot_build_packages</span><br><span class="line"><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span>.</span><br><span class="line">6# Starting rootfs <span class="keyword">and</span> image building process</span><br><span class="line">debootstrap_ng</span><br><span class="line"><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span>.</span><br><span class="line">7# make the image</span><br><span class="line">prepare_partitions</span><br><span class="line">create_image</span><br></pre></td></tr></table></figure><h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><ol><li>里面有非常多的细节，要花些时间看明白，尤其要对shell scripts比较熟悉。</li><li>ramfs、Initramfs、ramdisk、inittrd、rootfs、tmpfs的区别，参考<a href="https://www.kernel.org/doc/Documentation/filesystems/ramfs-rootfs-initramfs.txt" target="_blank" rel="noopener">ramfs-rootfs-initramfs</a>。看了半天貌似也没看懂。简单来说，ramdisk是一种基于ram的块设备，ramfs是一种基于ram的文件系统，开发ramfs的目的是因为ramdisk浪费了太多的内存cache页。initrd是init ramdisk的缩写，initramfs是init ramfs的缩写。名称里加了init前缀，代表它们具有了引导内核启动的功能。</li><li>自己做的过程中，添加了一个自动挂载硬盘的功能，通过udev，但发现FAT32可以挂载，NTFS不能，网上searching一番并多次尝试，最终找到可行解决方案。参考如下<a href="https://serverfault.com/a/767079" target="_blank" rel="noopener">自动挂载</a>。也有第三方的解决方案，如autofs, HAL, udisks, udisks2, usbmount，并未尝试。另，一些有用的调试命令：</li></ol><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">udevadm info /dev/sda1 --此命令可以查看相关设备的udev属性，依据此来写rules。</span><br><span class="line">udevadm<span class="built_in"> monitor </span>--udev  --观察 uevent事件</span><br><span class="line">blkid   fdisk   lsblk</span><br></pre></td></tr></table></figure><p>以上只是一些索引记录，供参考。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;img src=&quot;/2018/04/20/Build-Ubuntu-for-ARM-Platform-From-Scratch/linux.jpg&quot;&gt;
&lt;h3 id=&quot;起点&quot;&gt;&lt;a href=&quot;#起点&quot; class=&quot;headerlink&quot; title=&quot;起点&quot;&gt;&lt;/a&gt;起点&lt;
      
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>一文了解Linux command and Shell</title>
    <link href="http://yoursite.com/2018/04/20/Linux-command-and-shell/"/>
    <id>http://yoursite.com/2018/04/20/Linux-command-and-shell/</id>
    <published>2018-04-20T07:35:39.000Z</published>
    <updated>2018-04-20T07:43:37.652Z</updated>
    
    <content type="html"><![CDATA[<img src="/2018/04/20/Linux-command-and-shell/bash.png"><h2 id="系统命令何其多"><a href="#系统命令何其多" class="headerlink" title="系统命令何其多"></a>系统命令何其多</h2><p>Linux下命令那么多，好几千个，怎么办？用man查询，如 man ls（查看ls的用法）。</p><hr><p>看一看有哪些常用命令-&gt;</p><h4 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h4><ul><li>UID，GID</li></ul><p>常用命令：<code>id, who, /etc/passwd, groups</code></p><p>账号管理： <code>useradd, passwd, usermod, userdel, groupadd, groupdel, w</code></p><h4 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h4><p>常用命令： <code>pwd, touch, chmod, chown, which, whereis</code></p><ul><li>find</li></ul><p>查找指定文件并删除：<br><code>find android/ -maxdepth 3 -type f -a -name 2.log -delete</code></p><p>删除所有文件仅保留特定文件：<br><code>find android/ -type f -not -a -name &#39;*.java&#39; -delete</code></p><p>查找指定文件并搜索：<br><code>find android/ -type f -a -name &#39;*.java&#39; | grep -rn &quot;activity&quot;</code></p><ul><li>打包： <code>zip, tar</code></li></ul><p>例子：Android压缩SDK：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zcvf xxx.tar.gz sdk_directory_name --exclude=.repo --exclude=.git --exclude=sdk_directory_name/uboot/build --exclude=sdk_directory_name/out --exclude=sdk_directory_name/ S82_SDK_20141121.tar.gz</span><br></pre></td></tr></table></figure></p><p>分卷压缩,网盘上传文件大小有限制这个命令会用到：</p><p><code>tar -zcvf - .repo/ |split -b 4000M - xxx_sdk.tar.gz</code></p><h4 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h4><p><code>df, fdisk, mount, lsblk, blkid, /etc/fstab(设置自动挂载)，ln -s(软链接)</code></p><h4 id="字符处理"><a href="#字符处理" class="headerlink" title="字符处理"></a>字符处理</h4><p>grep：<code>-r : 迭代到子文件夹；  -n：行号；  -i：不区分大小写</code></p><p>sort：<code>-n 数字排序   -r 反向排序  -t 指定分隔符</code></p><p>uniq：删除重复内容</p><p>cut：截取文本</p><h4 id="网络管理"><a href="#网络管理" class="headerlink" title="网络管理"></a>网络管理</h4><p>指定IP地址：<code>ipconfig eth0 192.168.1.6 netmask 255.255.255.0</code></p><p>手动打开断开网卡：<code>ifconfig eth0 up/ifconfig etho down</code></p><p>查看系统路由表：<code>route -n</code></p><p>DNS: <code>/etc/hosts， /etc/resolv.conf</code></p><h4 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h4><p><code>ps, top, kill, nice</code></p><h4 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h4><p><a href="https://blog.csdn.net/u012359618/article/details/51498959" target="_blank" rel="noopener">8种字符串截取方法</a></p><ul><li>sed与awk的区别：</li></ul><p>如果文件是格式化的，即由分隔符分为多个域的，优先使用awk；</p><p>awk适合按列（域）操作，sed适合按行操作；</p><p>awk适合对文件的抽取整理，sed适合对文件的编辑。</p><hr><h2 id="shell编程"><a href="#shell编程" class="headerlink" title="shell编程"></a>shell编程</h2><h4 id="shell-内建命令"><a href="#shell-内建命令" class="headerlink" title="shell 内建命令"></a>shell 内建命令</h4><p>由bash自身提供的命令，而不是/bin下某个可执行文件，比如：<code>cd，source</code>。如何确定，通过type。</p><p>alias，别名，可以在.bashrc中定制。</p><p>任务前后台切换：bg、fg、jobs。可与Ctrl+z、&amp;联合使用。典型场景是运行比较耗时任务。</p><p>./， .， source 三者执行shell的区别。</p><p>exec：不启动新的shell，而是用要被执行的命令替换当前的shell脚本。exec命令后其他命令将不再执行，且会断开ssh链接。所以一般放到一个子脚本中运行。</p><p>source，就是让script在当前shell内执行、 而不是产生一个sub-shell来执行。 由于所有执行结果均在当前shell内执行、而不是产生一个sub-shell来执行。跟 <code>. xxx.sh</code> 一样效果。</p><p><code>./xxx.sh</code> 是直接fork一个子进程来执行。</p><p>export：跨脚本传递变量。</p><p>read:从标准输入读取一行。</p><p>脚本参数： <code>$1 第一个参数 $2 第二个参数 …… $@ 所有参数  $# 参数个数  $0 脚本本身 $? 上一条命令返回值</code></p><h4 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h4><ol><li>局部变量，只在某个shell中生效。也可用<code>local</code>声明，在函数中生效。</li><li>环境变量，也叫全局变量。系统中有预设一些环境变量，如<code>HOME，PATH</code>，可以通过 <code>echo $PATH</code>访问。<br>如果需要在shell中导出变量给其他子shell中使用可以通过：<code>export VAR=value</code>。</li><li>变量的赋值与取值。变量名与值用<code>=</code>紧紧相连，中间不能有空格。${}是比$更保险的做法。如果值也是引用变量，要用<code>&quot;&quot;</code>,如<code>name=&quot;${name1}&quot;</code>。<code>unset</code>可以取消变量。只读变量通过readonly声明，或是<code>declare -r</code>。</li><li>转义通过<code>\</code>来让特殊字符输出。</li><li>命令替换是指将标准输出作为值赋给某个变量：<code>$(命令)</code>.</li><li><p>()与{}的差别：</p><p> () 将command group置于sub-shell(子shell)中去执行，也称 nested sub-shell。<br> {} 则是在同一个shell内完成，也称non-named command group。</p></li><li><p>常见算术运算符大多需要结合shell的内建命令let来使用。</p></li><li><code>$(())</code> 用来作整数运算的.</li><li><p>Wildcard与Regular Expression的差别.</p><p> wildcard只作用于argument的path上；而RE却只用于”字符串处理” 的程序中，如某些文字处理工具之间：grep， perl， vi，awk，sed，等等， 常用于表示一段连续的字符串，查找和替换,这与路径名一点关系也没有。</p></li></ol><h4 id="测试判断与循环"><a href="#测试判断与循环" class="headerlink" title="测试判断与循环"></a>测试判断与循环</h4><p>测试结构：</p><p><code>test expression</code>   or   <code>[ expression ] 括号内两边有空格</code> 建议采用后面的方式，更容易跟if  while case 这些连用。</p><p>文件测试，常用参数：<code>-e 文件或目录是否存在；-f 文件是否存在；-d 目录是否存在</code>。</p><p>字符串：<code>-z 是否为空；-n 非空返回真；= !=</code></p><p>整数比较：<code>-eq  -gt  -lt</code></p><p>逻辑：两种方式 <code>! -a -o</code>  or  <code>! &amp;&amp; ||</code>。</p><p>command1 &amp;&amp; command2 # command2只有在command1的RV为0(true)的条件下执行。</p><p>command1 || command2 # command2 只有在command1的RV为非0(false)的条件下执行。</p><p>[]与[[]]的区别<a href="http://www.zsythink.net/archives/2252" target="_blank" rel="noopener">Reference</a>：</p><p>当使用‘-n’‘-z’这种判断方式时，‘[]’需要在其中的变量外侧加上双引号，与test命令的用法一致，而使用<code>[[]]</code>时不用。</p><p>判断某个变量的值是否满足某个正则表达式，可以用符号<code>=~</code> + <code>[[]]</code>。</p><p>if 判断结构：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ expression ]; <span class="keyword">then</span></span><br><span class="line">    cmd1</span><br><span class="line"><span class="keyword">elif</span> [ exp1 ]; <span class="keyword">then</span></span><br><span class="line">    cmd2</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    cmd3</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p>case 判断结构：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">case VAR in</span><br><span class="line"></span><br><span class="line">var1) cmd1<span class="comment">;;</span></span><br><span class="line">var2) cmd2<span class="comment">;;</span></span><br><span class="line">*) cmd3<span class="comment">;;</span></span><br><span class="line"></span><br><span class="line">esac</span><br></pre></td></tr></table></figure><p>for 循环：</p><figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="type">VAR</span> <span class="keyword">in</span> (<span class="built_in">list</span>)</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line"></span><br><span class="line">    cmd</span><br><span class="line"></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>while 循环：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> expression</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    cmd</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>until循环结构：（测试假值）。</p><p>select循环，是一种菜单扩展循环方式，等待用户输入在执行。</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> MENU <span class="keyword">in</span> (<span class="built_in">list</span>)</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    cmd</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>循环控制：break、continue。</p><h4 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h4><p>系统在启动一个进程时会同时打开三个文件：标准输入（stdin）、标准输出（stdout）、标准错误输出（stderr），分别用文件标识符0、1 、2来标识。标准输入为键盘，标准输出及错误输出默认为显示器或是串口。</p><p>> ：标准输出覆盖重定向，会覆盖原始文件。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ls -l /usr/ &gt; ls_usr.txt</span><br><span class="line">等价于</span><br><span class="line">ls -l /usr/ 1&gt; ls_usr.txt</span><br></pre></td></tr></table></figure></p><p>>>: 追加重定向。不清空原始文件。</p><p>>\&amp;: 标识输出重定向，将一个标识的输出重定向到另一个标识的输入。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">COMMAND &gt; stdout_stderr.txt 2&gt;&amp;1 </span><br><span class="line">#2&gt;&amp;1代表 错误输出重定向到标准输出，同时打印到文件中。</span><br><span class="line"></span><br><span class="line">2&gt; /dev/null  #丢弃错误输出</span><br></pre></td></tr></table></figure><p>&lt; : 标准输入重定向。</p><p>&lt;&lt;: 这是所谓的here document, 它可以让我们输入一段文本， 直到读到&lt;&lt; 后指定的字符串。比方说：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ cat &lt;&lt;<span class="literal">EOF</span></span><br><span class="line"><span class="keyword">first</span> <span class="built_in">line</span> here</span><br><span class="line"><span class="keyword">second</span> <span class="built_in">line</span> here</span><br><span class="line"><span class="keyword">third</span> <span class="built_in">line</span> here</span><br><span class="line"><span class="literal">EOF</span></span><br></pre></td></tr></table></figure><p>| ： 管道，将一个命令的输出作为另一个命令的输入。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><ul><li>还不错的参考</li></ul><p><a href="https://github.com/wzb56/13_questions_of_shell" target="_blank" rel="noopener">shell 十三问</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;img src=&quot;/2018/04/20/Linux-command-and-shell/bash.png&quot;&gt;
&lt;h2 id=&quot;系统命令何其多&quot;&gt;&lt;a href=&quot;#系统命令何其多&quot; class=&quot;headerlink&quot; title=&quot;系统命令何其多&quot;&gt;&lt;/a&gt;系统命令何其多&lt;
      
    
    </summary>
    
      <category term="shell" scheme="http://yoursite.com/categories/shell/"/>
    
    
      <category term="shell" scheme="http://yoursite.com/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>Build github pages with Hexo+NexT</title>
    <link href="http://yoursite.com/2018/04/17/Build%20github%20pages%20with%20Hexo+NexT/"/>
    <id>http://yoursite.com/2018/04/17/Build github pages with Hexo+NexT/</id>
    <published>2018-04-17T08:45:50.000Z</published>
    <updated>2018-04-18T03:28:33.717Z</updated>
    
    <content type="html"><![CDATA[<img src="/2018/04/17/Build%20github%20pages%20with%20Hexo+NexT/hexo-github.png"><p>主要记录在Windows下搭建博客系统的一些简要步骤，具体参考相关链接。</p><blockquote><p><em>PS：为了建这个博客，Search了网络上的一些信息，很多都是只言片语且不够全面，甚至过时。所以最好的做法是参考原始出处、原始文档，一是原始的更全面，二是会时时更新。</em></p></blockquote><h3 id="系统环境配置（Windows）"><a href="#系统环境配置（Windows）" class="headerlink" title="系统环境配置（Windows）"></a>系统环境配置（Windows）</h3><p>主要需要以下三个软件，按顺序安装(点击进官网查看相关)：</p><ul><li><a href="http://git-scm.com/download/" target="_blank" rel="noopener">git-scm</a></li><li><a href="https://nodejs.org/en/" target="_blank" rel="noopener">Nodejs</a></li><li><a href="https://hexo.io" target="_blank" rel="noopener">Hexo</a></li></ul><h3 id="Hexo相关"><a href="#Hexo相关" class="headerlink" title="Hexo相关"></a>Hexo相关</h3><ul><li>安装Hexo</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> d:/hexo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> npm install hexo-cli -g</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> hexo init blog</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> blog</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> npm install</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> hexo g <span class="comment"># 或者hexo generate</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> hexo s <span class="comment"># 或者hexo server，可以在http://localhost:4000/ 查看</span></span></span><br></pre></td></tr></table></figure><ul><li><p><a href="https://hexo.io/docs/" target="_blank" rel="noopener">Hexo常用命令及用法-点击进官网</a></p><ul><li><code>hexo generate (hexo g)</code> 生成静态文件，会在当前目录下生成一个新的叫做public的文件夹</li><li><code>hexo server (hexo s)</code> 启动本地web服务，用于博客的预览</li><li><code>hexo deploy (hexo d)</code> 部署播客到远端（比如github, heroku等平台）</li><li><code>hexo new &quot;postName&quot;</code> #新建文章</li><li><code>hexo new page &quot;pageName&quot;</code> #新建页面</li><li><code>hexo clean</code>  清除静态资源</li></ul></li></ul><h3 id="Next主题"><a href="#Next主题" class="headerlink" title="Next主题"></a><a href="http://theme-next.iissnan.com/" target="_blank" rel="noopener">Next主题</a></h3><ul><li><p>clone <a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="noopener">NexT主题</a></p><blockquote><p>git clone <a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="noopener">https://github.com/iissnan/hexo-theme-next</a></p></blockquote></li></ul><p>其中有个问题，如何将站点及主题的配置整合到一起，并合理的保存，参考NexT的 README中描述。</p><ul><li>相关配置（大多在主题_config.yaml中可配置）<ul><li>添加categories、tags（参考官方github README）</li><li>站点访问次数<ul><li>不蒜子 <a href="http://busuanzi.ibruce.info/" target="_blank" rel="noopener">http://busuanzi.ibruce.info/</a> </li><li>busuanzi_count: true</li></ul></li><li>站内搜索<ul><li>algolia_search</li><li>local_search</li></ul></li><li>文章访问次数<ul><li>leancloud_visitors</li></ul></li><li>评论添加（有多种配置，参考_config.yaml）<ul><li>youyan_uid （<a href="http://www.uyan.cc）" target="_blank" rel="noopener">http://www.uyan.cc）</a></li></ul></li></ul></li></ul><h3 id="项目托管到github"><a href="#项目托管到github" class="headerlink" title="项目托管到github"></a>项目托管到github</h3><ul><li>创建github pages<ul><li>在github上新建仓库，且仓库的名字必须是username/username.github.io</li></ul></li><li>部署<ul><li>配置ssh-key:<code>ssh-keygen -t rsa -C &quot;注册git的邮箱&quot;</code>；</li><li>打开<a href="https://github.com/settings/ssh" target="_blank" rel="noopener">https://github.com/settings/ssh</a> -&gt;new SSH key 添加密钥，title随便写，key为id_rsa.pub中所有内容；</li><li>验证是否能否连接到github: <code>ssh -T git@github.com</code></li><li>同步到github<ul><li>首先安装：<code>npm install hexo-deployer-git --save</code></li><li>在blog目录执行： <code>hexo d</code></li></ul></li></ul></li></ul><p>按以上配置，基本上一个github pages基本完成，接下来要考虑如何编辑。</p><h3 id="编辑相关"><a href="#编辑相关" class="headerlink" title="编辑相关"></a>编辑相关</h3><ul><li><p>Markdown 编辑器选择</p><ul><li>Visual studio Code</li><li><a href="https://github.com/zhuzhuyule/HexoEditor/releases" target="_blank" rel="noopener">HexoEditor</a></li></ul></li><li><p>如何插入图片（<a href="https://hexo.io/docs/asset-folders.html" target="_blank" rel="noopener">Link</a>）</p><ul><li>post_asset_folder: true</li><li>asset_img</li></ul></li><li><p>如何插入代码（<a href="https://hexo.io/docs/tag-plugins.html" target="_blank" rel="noopener">Link</a>）</p><ul><li>采用 codeblock</li><li>3个`</li></ul></li></ul><div class="note default"><p>```[language] [title] [url] [link-text]</p><p><code>代码</code></p><p>```</p></div><p>[language] 是代码语言的名称，用来设置代码块颜色高亮，非必须；</p><p>[title] 是顶部左边的说明，非必须；</p><p>[url] 是顶部右边的超链接地址，非必须；</p><p>[link text] 如它的字面意思，超链接的名称，非必须。</p><p>亲测这 4 项应该是根据空格来分隔，而不是[]，故请不要加[]。除非如果你想写后面两个，但不想写前面两个，那么就必须加[]了，要这样写：<code>[] [] [url] [link text]</code>。</p><ul><li>如何添加categories&amp;tags（<a href="https://hexo.io/docs/front-matter.html" target="_blank" rel="noopener">Link</a>）</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>为什么选择github pages+hexo方案，最大的原因是免费，且有清新简约的Hexo引擎加上各种主题，然后可以在github上面保存Tracking。</p><p>在实施的过程中，最好是通读原始的文档，然后多实际尝试，一步一步会达到想要的结果。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;img src=&quot;/2018/04/17/Build%20github%20pages%20with%20Hexo+NexT/hexo-github.png&quot;&gt;
&lt;p&gt;主要记录在Windows下搭建博客系统的一些简要步骤，具体参考相关链接。&lt;/p&gt;
&lt;blockquote&gt;
&lt;
      
    
    </summary>
    
      <category term="web" scheme="http://yoursite.com/categories/web/"/>
    
    
      <category term="web" scheme="http://yoursite.com/tags/web/"/>
    
  </entry>
  
</feed>
