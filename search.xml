<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[从头开始移植Ubuntu系统到ARM平台（基于全志H3）]]></title>
    <url>%2F2018%2F04%2F20%2FBuild-Ubuntu-for-ARM-Platform-From-Scratch%2F</url>
    <content type="text"><![CDATA[起点在ARM SOC上移植Ubuntu系统并不是一件容易的事情，要对镜像文件的组成，系统的启动顺序非常熟悉。在网上searching一番，发现一个很神奇的网站-&gt;Armbian,这个网站开发者在大量的开发板上做了移植工作，包括allwinner H3/H5、Rockchip RK3328、amlogic S905x等，并且有详细的文档，以及开源的编译系统。 其实，参考Armbian的文档，即可搭建好完整编译环境，并针对你的板子（前提是里面已经支持的SoC）修改uboot、kernel、编译脚本即可定制，都是开源的。我尝试在H3平台上搭建，并成功制作了镜像，进到了系统。 编译系统如果需要定制一些功能，如添加、删除一些脚本，应用程序，就必须完整看懂整个编译逻辑。Armbian上介绍是： 从khadas开发板网站 上有更形象的图（但未必准确，尤其是对Initramfs与inittrd的理解）： 对照编译脚本来看： 从根目录compile.sh开始，进入main.sh，主要工作在后者里完成，关键步骤： 1234567891011121314151617181920212223241# Check and install dependencies, directory structure and settingsprepare_host...........2# 下载uboot及kernelfetch_from_repo "$BOOTSOURCE" "$BOOTDIR" "$BOOTBRANCH" "yes"fetch_from_repo "$KERNELSOURCE" "$KERNELDIR" "$KERNELBRANCH" "yes"...........3# Compile u-boot if packed .deb does not existcompile_uboot...........4# Compile kernel if packed .deb does not existcompile_kernel...........5# create board support package /create desktop package / build additional packagescreate_board_packagecreate_desktop_packagechroot_build_packages...........6# Starting rootfs and image building processdebootstrap_ng...........7# make the imageprepare_partitionscreate_image 后记 里面有非常多的细节，要花些时间看明白，尤其要对shell scripts比较熟悉。 ramfs、Initramfs、ramdisk、inittrd、rootfs、tmpfs的区别，参考ramfs-rootfs-initramfs。看了半天貌似也没看懂。简单来说，ramdisk是一种基于ram的块设备，ramfs是一种基于ram的文件系统，开发ramfs的目的是因为ramdisk浪费了太多的内存cache页。initrd是init ramdisk的缩写，initramfs是init ramfs的缩写。名称里加了init前缀，代表它们具有了引导内核启动的功能。 自己做的过程中，添加了一个自动挂载硬盘的功能，通过udev，但发现FAT32可以挂载，NTFS不能，网上searching一番并多次尝试，最终找到可行解决方案。参考如下自动挂载。也有第三方的解决方案，如autofs, HAL, udisks, udisks2, usbmount，并未尝试。另，一些有用的调试命令： 123udevadm info /dev/sda1 --此命令可以查看相关设备的udev属性，依据此来写rules。udevadm monitor --udev --观察 uevent事件blkid fdisk lsblk 以上只是一些索引记录，供参考。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一文了解Linux command and Shell]]></title>
    <url>%2F2018%2F04%2F20%2FLinux-command-and-shell%2F</url>
    <content type="text"><![CDATA[系统命令何其多Linux下命令那么多，好几千个，怎么办？用man查询，如 man ls（查看ls的用法）。 看一看有哪些常用命令-&gt; 用户管理 UID，GID 常用命令：id, who, /etc/passwd, groups 账号管理： useradd, passwd, usermod, userdel, groupadd, groupdel, w 文件管理常用命令： pwd, touch, chmod, chown, which, whereis find 查找指定文件并删除：find android/ -maxdepth 3 -type f -a -name 2.log -delete 删除所有文件仅保留特定文件：find android/ -type f -not -a -name &#39;*.java&#39; -delete 查找指定文件并搜索：find android/ -type f -a -name &#39;*.java&#39; | grep -rn &quot;activity&quot; 打包： zip, tar 例子：Android压缩SDK：1tar -zcvf xxx.tar.gz sdk_directory_name --exclude=.repo --exclude=.git --exclude=sdk_directory_name/uboot/build --exclude=sdk_directory_name/out --exclude=sdk_directory_name/ S82_SDK_20141121.tar.gz 分卷压缩,网盘上传文件大小有限制这个命令会用到： tar -zcvf - .repo/ |split -b 4000M - xxx_sdk.tar.gz 文件系统df, fdisk, mount, lsblk, blkid, /etc/fstab(设置自动挂载)，ln -s(软链接) 字符处理grep：-r : 迭代到子文件夹； -n：行号； -i：不区分大小写 sort：-n 数字排序 -r 反向排序 -t 指定分隔符 uniq：删除重复内容 cut：截取文本 网络管理指定IP地址：ipconfig eth0 192.168.1.6 netmask 255.255.255.0 手动打开断开网卡：ifconfig eth0 up/ifconfig etho down 查看系统路由表：route -n DNS: /etc/hosts， /etc/resolv.conf 进程管理ps, top, kill, nice 正则表达式8种字符串截取方法 sed与awk的区别： 如果文件是格式化的，即由分隔符分为多个域的，优先使用awk； awk适合按列（域）操作，sed适合按行操作； awk适合对文件的抽取整理，sed适合对文件的编辑。 shell编程shell 内建命令由bash自身提供的命令，而不是/bin下某个可执行文件，比如：cd，source。如何确定，通过type。 alias，别名，可以在.bashrc中定制。 任务前后台切换：bg、fg、jobs。可与Ctrl+z、&amp;联合使用。典型场景是运行比较耗时任务。 ./， .， source 三者执行shell的区别。 exec：不启动新的shell，而是用要被执行的命令替换当前的shell脚本。exec命令后其他命令将不再执行，且会断开ssh链接。所以一般放到一个子脚本中运行。 source，就是让script在当前shell内执行、 而不是产生一个sub-shell来执行。 由于所有执行结果均在当前shell内执行、而不是产生一个sub-shell来执行。跟 . xxx.sh 一样效果。 ./xxx.sh 是直接fork一个子进程来执行。 export：跨脚本传递变量。 read:从标准输入读取一行。 脚本参数： $1 第一个参数 $2 第二个参数 …… $@ 所有参数 $# 参数个数 $0 脚本本身 $? 上一条命令返回值 基础 局部变量，只在某个shell中生效。也可用local声明，在函数中生效。 环境变量，也叫全局变量。系统中有预设一些环境变量，如HOME，PATH，可以通过 echo $PATH访问。如果需要在shell中导出变量给其他子shell中使用可以通过：export VAR=value。 变量的赋值与取值。变量名与值用=紧紧相连，中间不能有空格。${}是比$更保险的做法。如果值也是引用变量，要用&quot;&quot;,如name=&quot;${name1}&quot;。unset可以取消变量。只读变量通过readonly声明，或是declare -r。 转义通过\来让特殊字符输出。 命令替换是指将标准输出作为值赋给某个变量：$(命令). ()与{}的差别： () 将command group置于sub-shell(子shell)中去执行，也称 nested sub-shell。 {} 则是在同一个shell内完成，也称non-named command group。 常见算术运算符大多需要结合shell的内建命令let来使用。 $(()) 用来作整数运算的. Wildcard与Regular Expression的差别. wildcard只作用于argument的path上；而RE却只用于”字符串处理” 的程序中，如某些文字处理工具之间：grep， perl， vi，awk，sed，等等， 常用于表示一段连续的字符串，查找和替换,这与路径名一点关系也没有。 测试判断与循环测试结构： test expression or [ expression ] 括号内两边有空格 建议采用后面的方式，更容易跟if while case 这些连用。 文件测试，常用参数：-e 文件或目录是否存在；-f 文件是否存在；-d 目录是否存在。 字符串：-z 是否为空；-n 非空返回真；= != 整数比较：-eq -gt -lt 逻辑：两种方式 ! -a -o or ! &amp;&amp; ||。 command1 &amp;&amp; command2 # command2只有在command1的RV为0(true)的条件下执行。 command1 || command2 # command2 只有在command1的RV为非0(false)的条件下执行。 []与[[]]的区别Reference： 当使用‘-n’‘-z’这种判断方式时，‘[]’需要在其中的变量外侧加上双引号，与test命令的用法一致，而使用[[]]时不用。 判断某个变量的值是否满足某个正则表达式，可以用符号=~ + [[]]。 if 判断结构： 1234567if [ expression ]; then cmd1elif [ exp1 ]; then cmd2else cmd3fi case 判断结构： 1234567case VAR invar1) cmd1;;var2) cmd2;;*) cmd3;;esac for 循环： 123456for VAR in (list)do cmddone while 循环： 1234while expressiondo cmddone until循环结构：（测试假值）。 select循环，是一种菜单扩展循环方式，等待用户输入在执行。 1234select MENU in (list)do cmddone 循环控制：break、continue。 重定向系统在启动一个进程时会同时打开三个文件：标准输入（stdin）、标准输出（stdout）、标准错误输出（stderr），分别用文件标识符0、1 、2来标识。标准输入为键盘，标准输出及错误输出默认为显示器或是串口。 > ：标准输出覆盖重定向，会覆盖原始文件。1234ls -l /usr/ &gt; ls_usr.txt等价于ls -l /usr/ 1&gt; ls_usr.txt >>: 追加重定向。不清空原始文件。 >\&amp;: 标识输出重定向，将一个标识的输出重定向到另一个标识的输入。 1234COMMAND &gt; stdout_stderr.txt 2&gt;&amp;1 #2&gt;&amp;1代表 错误输出重定向到标准输出，同时打印到文件中。2&gt; /dev/null #丢弃错误输出 &lt; : 标准输入重定向。 &lt;&lt;: 这是所谓的here document, 它可以让我们输入一段文本， 直到读到&lt;&lt; 后指定的字符串。比方说： 12345$ cat &lt;&lt;EOFfirst line heresecond line herethird line hereEOF | ： 管道，将一个命令的输出作为另一个命令的输入。 最后 还不错的参考 shell 十三问]]></content>
      <categories>
        <category>shell</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Build github pages with Hexo+NexT]]></title>
    <url>%2F2018%2F04%2F17%2FBuild%20github%20pages%20with%20Hexo%2BNexT%2F</url>
    <content type="text"><![CDATA[主要记录在Windows下搭建博客系统的一些简要步骤，具体参考相关链接。 PS：为了建这个博客，Search了网络上的一些信息，很多都是只言片语且不够全面，甚至过时。所以最好的做法是参考原始出处、原始文档，一是原始的更全面，二是会时时更新。 系统环境配置（Windows）主要需要以下三个软件，按顺序安装(点击进官网查看相关)： git-scm Nodejs Hexo Hexo相关 安装Hexo 1234567$ cd d:/hexo$ npm install hexo-cli -g$ hexo init blog$ cd blog$ npm install$ hexo g # 或者hexo generate$ hexo s # 或者hexo server，可以在http://localhost:4000/ 查看 Hexo常用命令及用法-点击进官网 hexo generate (hexo g) 生成静态文件，会在当前目录下生成一个新的叫做public的文件夹 hexo server (hexo s) 启动本地web服务，用于博客的预览 hexo deploy (hexo d) 部署播客到远端（比如github, heroku等平台） hexo new &quot;postName&quot; #新建文章 hexo new page &quot;pageName&quot; #新建页面 hexo clean 清除静态资源 Next主题 clone NexT主题 git clone https://github.com/iissnan/hexo-theme-next 其中有个问题，如何将站点及主题的配置整合到一起，并合理的保存，参考NexT的 README中描述。 相关配置（大多在主题_config.yaml中可配置） 添加categories、tags（参考官方github README） 站点访问次数 不蒜子 http://busuanzi.ibruce.info/ busuanzi_count: true 站内搜索 algolia_search local_search 文章访问次数 leancloud_visitors 评论添加（有多种配置，参考_config.yaml） youyan_uid （http://www.uyan.cc） 项目托管到github 创建github pages 在github上新建仓库，且仓库的名字必须是username/username.github.io 部署 配置ssh-key:ssh-keygen -t rsa -C &quot;注册git的邮箱&quot;； 打开https://github.com/settings/ssh -&gt;new SSH key 添加密钥，title随便写，key为id_rsa.pub中所有内容； 验证是否能否连接到github: ssh -T git@github.com 同步到github 首先安装：npm install hexo-deployer-git --save 在blog目录执行： hexo d 按以上配置，基本上一个github pages基本完成，接下来要考虑如何编辑。 编辑相关 Markdown 编辑器选择 Visual studio Code HexoEditor 如何插入图片（Link） post_asset_folder: true asset_img 如何插入代码（Link） 采用 codeblock 3个` ```[language] [title] [url] [link-text] 代码 ``` [language] 是代码语言的名称，用来设置代码块颜色高亮，非必须； [title] 是顶部左边的说明，非必须； [url] 是顶部右边的超链接地址，非必须； [link text] 如它的字面意思，超链接的名称，非必须。 亲测这 4 项应该是根据空格来分隔，而不是[]，故请不要加[]。除非如果你想写后面两个，但不想写前面两个，那么就必须加[]了，要这样写：[] [] [url] [link text]。 如何添加categories&amp;tags（Link） 总结为什么选择github pages+hexo方案，最大的原因是免费，且有清新简约的Hexo引擎加上各种主题，然后可以在github上面保存Tracking。 在实施的过程中，最好是通读原始的文档，然后多实际尝试，一步一步会达到想要的结果。]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
</search>
